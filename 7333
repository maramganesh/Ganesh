#include <bits/stdc++.h>
using namespace std;

int R, C, N;
vector<vector<pair<int,int>>> threat;

// For each traveler and each cell, store threat mask
vector<vector<long long>> threatMask;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> R >> C;
    cin >> N;

    int total = R * C;

    threat.resize(N);

    for (int i = 0; i < N; i++) {
        int k;
        cin >> k;
        while (k--) {
            int dr, dc;
            cin >> dr >> dc;
            threat[i].push_back({dr, dc});
        }
    }

    // Precompute threat masks
    threatMask.assign(N, vector<long long>(total, 0));

    for (int i = 0; i < N; i++) {
        for (int cell = 0; cell < total; cell++) {

            int r = cell / C;
            int c = cell % C;

            long long mask = 0;

            for (auto &t : threat[i]) {
                int nr = r + t.first;
                int nc = c + t.second;

                if (nr < 0 || nr >= R || nc < 0 || nc >= C)
                    continue;

                int ncell = nr * C + nc;
                mask |= (1LL << ncell);
            }

            threatMask[i][cell] = mask;
        }
    }

    int ans = 0;

    // Try all subsets of travelers
    for (int subset = 0; subset < (1 << N); subset++) {

        int cnt = __builtin_popcount(subset);
        if (cnt <= ans) continue;

        // collect travelers in this subset
        vector<int> travellers;
        for (int i = 0; i < N; i++)
            if (subset & (1 << i))
                travellers.push_back(i);

        // Backtracking over cells
        function<bool(int, long long, long long)> place =
        [&](int idx, long long occupied, long long threatened) {

            if (idx == travellers.size())
                return true;

            int t = travellers[idx];

            for (int cell = 0; cell < total; cell++) {

                if (occupied & (1LL << cell)) continue;
                if (threatened & (1LL << cell)) continue;

                long long newThreat = threatMask[t][cell];

                // cannot threaten occupied cells
                if (newThreat & occupied) continue;

                if (place(idx + 1,
                          occupied | (1LL << cell),
                          threatened | newThreat))
                    return true;
            }

            return false;
        };

        if (place(0, 0, 0))
            ans = cnt;
    }

    cout << ans << "\n";
    return 0;
}
