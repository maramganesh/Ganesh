#include <bits/stdc++.h>
using namespace std;

int r, c, n;
int ans = 0;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> r >> c;
    cin >> n;

    int tot = r * c;

    vector<vector<pair<int,int>>> shapes(n);

    for (int i = 0; i < n; i++) {
        int k;
        cin >> k;
        while (k--) {
            int x, y;
            cin >> x >> y;
            shapes[i].push_back({x, y});
        }
    }

    // mask[i][p] = bitmask of cells occupied if shape i placed at position p
    vector<vector<int>> mask(n, vector<int>(tot, 0));

    for (int i = 0; i < n; i++) {
        for (int p = 0; p < tot; p++) {

            int x = p / c;
            int y = p % c;

            int m = 0;
            bool valid = true;

            for (auto &q : shapes[i]) {
                int nx = x + q.first;
                int ny = y + q.second;

                if (nx < 0 || nx >= r || ny < 0 || ny >= c) {
                    valid = false;
                    break;
                }

                m |= (1 << (nx * c + ny));
            }

            if (valid)
                mask[i][p] = m;
            else
                mask[i][p] = 0;
        }
    }

    function<void(int,int,int)> dfs = [&](int id, int used, int cnt) {

        if (id == n) {
            ans = max(ans, cnt);
            return;
        }

        // Option 1: skip this shape
        dfs(id + 1, used, cnt);

        // Option 2: try placing shape at all positions
        for (int p = 0; p < tot; p++) {

            int m = mask[id][p];

            if (m == 0) continue;          // invalid placement
            if (used & m) continue;        // overlap

            dfs(id + 1, used | m, cnt + 1);
        }
    };

    dfs(0, 0, 0);

    cout << ans << "\n";
}
