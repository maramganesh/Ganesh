#include <bits/stdc++.h>
using namespace std;

vector<string> lines, expectedOutput;
int n;

/* ---------------- Utility ---------------- */

string trim(string s) {
    while (!s.empty() && isspace(s.back())) s.pop_back();
    while (!s.empty() && isspace(s.front())) s.erase(s.begin());
    return s;
}

vector<string> splitCode(string s) {
    vector<string> result;
    string cur = "";
    for (char c : s) {
        if (c == ';') {
            if (!cur.empty()) result.push_back(trim(cur));
            cur = "";
        } else {
            cur += c;
        }
    }
    if (!cur.empty()) result.push_back(trim(cur));
    return result;
}

/* ---------------- Simulator ---------------- */

bool simulate(vector<int> &indent) {

    map<string, int> intVars;
    map<string, string> strVars;

    vector<string> output;
    int i = 0;

    function<void(int)> run = [&](int level) {

        while (i < n) {

            if (indent[i] < level) return;
            if (indent[i] > level) return;

            string s = lines[i++];
            s = trim(s);

            /* -------- Assignment -------- */
            if (s.find("=") != string::npos &&
                s.find("==") == string::npos &&
                s.find("for ") != 0 &&
                s.find("while ") != 0 &&
                s.find("if ") != 0) {

                int pos = s.find("=");
                string L = trim(s.substr(0, pos));
                string R = trim(s.substr(pos + 1));

                if (R == "True") intVars[L] = 1;
                else if (R == "False") intVars[L] = 0;
                else if (isdigit(R[0]) || R[0] == '-')
                    intVars[L] = stoi(R);
                else if (R[0] == '"' || R[0] == '\'')
                    strVars[L] = R.substr(1, R.size() - 2);
                else if (intVars.count(R))
                    intVars[L] = intVars[R];
                else
                    strVars[L] = strVars[R];
            }

            /* -------- Print -------- */
            else if (s.find("print") == 0) {

                int p = s.find("(");
                int q = s.rfind(")");
                string x = trim(s.substr(p + 1, q - p - 1));

                if (x[0] == '"' || x[0] == '\'') {
                    output.push_back(x.substr(1, x.size() - 2));
                } else {
                    if (intVars.count(x))
                        output.push_back(to_string(intVars[x]));
                    else
                        output.push_back(strVars[x]);
                }
            }

            /* -------- While -------- */
            else if (s.find("while ") == 0) {

                int p = s.find("while ") + 6;
                int q = s.find(":");
                string cond = trim(s.substr(p, q - p));

                int save = i;

                auto check = [&]() {
                    if (cond.find(">") != string::npos) {
                        int pos = cond.find(">");
                        string a = trim(cond.substr(0, pos));
                        int b = stoi(trim(cond.substr(pos + 1)));
                        return intVars[a] > b;
                    }
                    if (cond.find("<") != string::npos) {
                        int pos = cond.find("<");
                        string a = trim(cond.substr(0, pos));
                        int b = stoi(trim(cond.substr(pos + 1)));
                        return intVars[a] < b;
                    }
                    return false;
                };

                while (check()) {
                    run(level + 1);
                    i = save;
                }

                while (i < n && indent[i] > level) i++;
            }

            /* -------- For -------- */
            else if (s.find("for ") == 0) {

                int p = s.find("range(");
                int q = s.find(")");
                string rangePart = s.substr(p + 6, q - p - 6);

                int start = 0, end;
                if (rangePart.find(",") != string::npos) {
                    int c = rangePart.find(",");
                    start = stoi(trim(rangePart.substr(0, c)));
                    end = stoi(trim(rangePart.substr(c + 1)));
                } else {
                    end = stoi(trim(rangePart));
                }

                string var = trim(s.substr(4, s.find(" in") - 4));
                int save = i;

                for (int k = start; k < end; k++) {
                    intVars[var] = k;
                    run(level + 1);
                    i = save;
                }

                while (i < n && indent[i] > level) i++;
            }

            /* -------- If -------- */
            else if (s.find("if ") == 0) {

                int p = s.find("if ") + 3;
                int q = s.find(":");
                string cond = trim(s.substr(p, q - p));

                bool ok = false;

                if (cond.find("%") != string::npos) {
                    int pos1 = cond.find("%");
                    int pos2 = cond.find("==");

                    string a = trim(cond.substr(0, pos1));
                    int b = stoi(trim(cond.substr(pos1 + 1, pos2 - pos1 - 1)));
                    int c = stoi(trim(cond.substr(pos2 + 2)));

                    ok = (intVars[a] % b == c);
                }
                else if (cond.find("==") != string::npos) {

                    int pos = cond.find("==");
                    string L = trim(cond.substr(0, pos));
                    string R = trim(cond.substr(pos + 2));

                    if (R[0] == '"' || R[0] == '\'')
                        ok = (strVars[L] == R.substr(1, R.size() - 2));
                    else if (isdigit(R[0]))
                        ok = (intVars[L] == stoi(R));
                    else
                        ok = (intVars[L] == intVars[R]);
                }

                int save = i;

                if (ok) {
                    run(level + 1);
                } else {
                    while (i < n && indent[i] > level) i++;
                }

                /* handle else */
                if (i < n && trim(lines[i]) == "else:" && indent[i] == level) {
                    i++;
                    if (!ok)
                        run(level + 1);
                    else
                        while (i < n && indent[i] > level) i++;
                }
            }
        }
    };

    run(0);
    return output == expectedOutput;
}

/* ---------------- DFS for indentation ---------------- */

bool dfs(int idx, vector<int> &indent) {

    if (idx == n) return simulate(indent);

    for (int k = 0; k <= n; k++) {

        indent[idx] = k;

        if (idx > 0 && indent[idx] > indent[idx - 1] + 1)
            continue;

        if (dfs(idx + 1, indent))
            return true;
    }

    return false;
}

/* ---------------- Main ---------------- */

int main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string codeLine;
    getline(cin, codeLine);

    lines = splitCode(codeLine);
    n = lines.size();

    string outLine;
    while (getline(cin, outLine)) {
        if (!trim(outLine).empty())
            expectedOutput.push_back(trim(outLine));
    }

    vector<int> indent(n, 0);

    if (dfs(0, indent)) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < indent[i] * 4; j++)
                cout << " ";
            cout << lines[i] << "\n";
        }
    } else {
        cout << "Not possible";
    }

    return 0;
}
